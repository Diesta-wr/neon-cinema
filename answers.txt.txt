Вопрос 1: Как вы можете описать процесс распространения событий в JavaScript (Event Propagation)? Расскажите о его основных фазах. Какие есть способы применения знаний о фазах распространения событий на практике?

Ответ:
Распространение событий (Event Propagation) — это механизм, по которому событие "перемещается" через DOM-дерево от целевого элемента к корню документа (или обратно). Существует три фазы:

1. Фаза захвата (Capture Phase) — событие проходит сверху вниз, от `document` к целевому элементу.
2. Фаза цели (Target Phase) — событие достигает целевого элемента.
3. Фаза всплытия (Bubbling Phase) — событие поднимается от целевого элемента к `document`.

На практике:
- Используется для делегирования событий — вместо навешивания обработчиков на каждый элемент, можно повесить один на родителя.
- Можно остановить распространение с помощью `event.stopPropagation()` или `event.stopImmediatePropagation()`.
- В `addEventListener` можно указать параметр `useCapture`: если `true` — обработчик срабатывает на фазе захвата, если `false` — на фазе всплытия (по умолчанию).

Пример:
element.addEventListener('click', handler, true); // capture phase
element.addEventListener('click', handler, false); // bubbling phase (default)


Вопрос 2: Расскажите, что такое Promise в JavaScript, как он работает, какие основные состояния у него бывают? Каким еще способом можно обработать асинхронный код? Какую роль в асинхронности играет событийный цикл (Event Loop)?

Ответ:
Promise — это объект, представляющий окончательное завершение (или неудачу) асинхронной операции и её результат.

Состояния Promise:
- pending — начальное состояние, ни исполнен, ни отклонён.
- fulfilled — операция успешно завершена.
- rejected — операция завершилась с ошибкой.

Методы:
- `.then()` — для успешного выполнения.
- `.catch()` — для обработки ошибок.
- `.finally()` — выполняется в любом случае.

Альтернативы:
- Callbacks — старый способ, но может приводить к "callback hell".
- Async/await — синтаксический сахар над Promises, делает код более читаемым.

Event Loop — механизм, который позволяет JavaScript быть однопоточным, но асинхронным. Он постоянно проверяет очередь задач (macro-tasks и micro-tasks) и исполняет их, когда стек вызовов пуст.

Пример:
async function fetchData() {
  try {
    const response = await fetch(url);
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error(error);
  }
}

Вопрос 3: Что такое ООП, и какие его ключевые принципы вы могли бы описать? При объяснении приводите примеры. Максимально подробно расскажите о том, как ООП реализовано в JavaScript.

Ответ:
ООП (Объектно-ориентированное программирование) — парадигма, основанная на понятии «объекта», который содержит данные и методы для работы с этими данными.

Основные принципы:
1. Инкапсуляция — сокрытие внутренней реализации объекта. В JS: использование замыканий или приватных полей (#field).
2. Наследование — возможность одного класса наследовать свойства и методы другого. В JS: через `extends` и `super`.
3. Полиморфизм — возможность объектов разных классов использовать один и тот же интерфейс. В JS: переопределение методов.
4. Абстракция — скрытие сложности, предоставление простого интерфейса.

Пример в JavaScript:
class Animal {
  constructor(name) {
    this.name = name;
  }
  speak() {
    console.log(`${this.name} издаёт звук.`);
  }
}

class Dog extends Animal {
  speak() {
    console.log(`${this.name} лает.`);
  }
}

const dog = new Dog("Барбос");
dog.speak(); // "Барбос лает."



Вопрос 4: Опишите максимально детально, как браузер обрабатывает URL, начиная с момента его ввода в адресную строку и заканчивая отображением страницы. Какие технологии позволяют ускорить процесс? Какие проблемы (безопасность, междоменное взаимодействие) могут возникать в процессе?

Ответ:
Процесс обработки URL браузером:

1. Ввод URL → браузер парсит его (протокол, домен, путь).
2. DNS-запрос — преобразование доменного имени в IP-адрес.
3. TCP-соединение — установка соединения с сервером.
4. HTTPS-рукопожатие (если используется SSL/TLS) — шифрование канала.
5. Отправка HTTP-запроса (GET, POST и т.д.).
6. Получение HTTP-ответа (статус, заголовки, тело).
7. Парсинг HTML — браузер строит DOM-дерево.
8. Загрузка ресурсов — CSS, JS, изображения.
9. Построение CSSOM — дерево стилей.
10. Объединение DOM и CSSOM в Render Tree.
11. Расчёт макета (Layout) — определение размеров и позиций элементов.
12. Рисование (Paint) — рендеринг на экран.
13. Композиция — объединение слоёв для вывода на экран.

Ускорение:
- CDN — доставка контента с ближайшего сервера.
- Кэширование — сохранение ресурсов локально.
- Минификация и сжатие — уменьшение размера файлов.
- Lazy loading — загрузка изображений и скриптов при необходимости.

Проблемы:
- Безопасность: XSS, CSRF, MITM-атаки — решаются через CSP, HTTPS, SameSite cookies.
- CORS — ограничение междоменного запроса — требует настройки сервера.
- Блокировка рекламы и скриптов — может ломать функциональность сайта.
